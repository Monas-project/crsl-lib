# 要件定義書

## 概要

この機能は、HEADの永続化を必要とせずに、任意のコンテンツの最新バージョンを効率的に取得することを可能にします。ノードに既存のgenesis追跡機能を活用することで、DAG構造を分析し、特定のコンテンツのバージョン履歴内でリーフノード（子を持たないノード）を特定することで、任意のコンテンツの最新バージョンを動的に計算できます。
a
## 要件

### 要件1

**ユーザーストーリー:** CRSLライブラリを使用する開発者として、genesis IDによって任意のコンテンツの最新バージョンを取得したい。これにより、バージョン履歴を手動で追跡することなく、最新の状態にアクセスできるようになる。

#### 受け入れ基準

1. `repo.latest(genesis_id)`を呼び出した時、システムはそのコンテンツの最新バージョンCIDを返すこと
2. genesis IDが存在しない時、システムはエラーを投げることなくNoneを返すこと
3. バージョンが1つしかない（genesisノード）時、システムはgenesis CID自体を返すこと
4. 線形履歴に複数のバージョンがある時、システムはリーフノードのCIDを返すこと

### 要件2

**ユーザーストーリー:** 開発者として、最新バージョンの計算が永続化ストレージなしで動作することを望む。これにより、システムがシンプルに保たれ、追加のストレージ管理が不要になる。

#### 受け入れ基準

1. アプリケーションが再起動した時、システムは依然として最新バージョンを正しく計算できること
2. 最新バージョンを計算する時、システムは永続的なHEADストレージを必要としないこと
3. 複数のプロセスが同じデータにアクセスする時、それぞれが独立して正しい最新バージョンを計算できること

### 要件3

**ユーザーストーリー:** 開発者として、最新バージョンの計算が効率的であることを望む。これにより、適度なバージョン履歴があってもアプリケーションのパフォーマンスに影響しない。

#### 受け入れ基準

1. kバージョンを持つコンテンツの最新バージョンを計算する時、アルゴリズムはO(N)時間計算量で完了すること（Nは全ノード数、genesisでフィルタ）
2. 複数のコンテンツがある時、1つのコンテンツの最新バージョン計算は関連のないコンテンツバージョンをスキャンしないこと
3. バージョン履歴が線形の時、この一般的なケースに対して計算が最適化されること

### 要件4

**ユーザーストーリー:** 開発者として、分岐したバージョン履歴の適切な処理を望む。これにより、コンテンツが並行して編集された時にシステムが予測可能に動作する。

#### 受け入れ基準

1. 複数のリーフノード（分岐）がある時、システムは最新のタイムスタンプを持つものを返すこと
2. 2つのリーフノードが同じタイムスタンプを持つ時、システムは一貫して1つを返すこと（決定的な動作）
3. 最新バージョンを計算する時、システムは親子関係をチェックしてリーフノードを正しく特定すること

### 要件5

**ユーザーストーリー:** CLIユーザーとして、コンテンツを表示する時に最新バージョン情報を見たい。これにより、データの現在の状態を理解できる。

#### 受け入れ基準

1. `show <content_id>`コマンドを実行した時、出力に最新バージョンCIDが含まれること
2. コンテンツに複数のバージョンがある時、コマンドは要求されたバージョンと最新バージョンの両方を表示すること
3. 要求されたcontent_idが既に最新バージョンの時、コマンドはこれを明確に示すこと

### 要件6

**ユーザーストーリー:** 開発者として、既存コードとの後方互換性を望む。これにより、現在のアプリケーションが変更なしで動作し続ける。

#### 受け入れ基準

1. 既存コードが`repo.latest()`を呼び出す時、同じインターフェースで動作し続けること
2. システムに既存のインメモリHEAD情報がある時、パフォーマンスのためのフォールバックとして使用されること
3. メモリベースから計算ベースのアプローチに移行する時、既存の機能は変更されないこと